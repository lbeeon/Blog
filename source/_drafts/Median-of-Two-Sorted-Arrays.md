title: Median of Two Sorted Arrays
date: 2016-03-09 23:13:30
tags:
- LeetCode
- Algorithm

---
最近因為一些緣故，所以我開始複習演算法(迷之音:我好像根本沒上過演算法的課...)，但是與其說是複習，不如說是重新學，因此就從網友都推薦的LeetCode下手。這次的題目是Median of Two Sorted Arrays，簡單敘述一下題目：

	給予兩個排序過的陣列以及陣列長度，並找出其中的中位數，而執行時間的複雜度為O(log(m+n))。

一看到這個題目，我想我和很多人一樣，第一個直覺是出現的演算法是merge sort，我也很快的用merge sort的方法實作，提交並且通過測試，但是在仔細想想題目要求的複雜度是O(log(m+n))，而merge sort的複雜度也只是O(m+n)，雖然提交的程式碼並沒有超時，但是還是想知道如何怎麼樣的演算法是符合O(log(m+n))，由於小弟資質駑鈍，著實想不出這樣的方法，只好上LeetCode的討論區找找答案，因如此才有這篇文章，也希望藉由這篇文章的翻譯和整理能讓我了解其中的演算法。

分享這個演算法的作者是[MissMary](https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation)，開門見山講的第一個重點就是，要解決這個問題就要先了解什麼是中位數，在統計學中，中位數就是指能將數列等分為二，且等分的兩個陣列其中一個子集合一定大於另一個子集合，在了解中位數可以做為芬等分數列的功用之後，那距離要求得解的路就不遠了。

首先，先在數列A中隨機取一個位置i，並將數列一分為二:

	     	left_A	        |          right_A
	A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]

由於數列A有m個元素，因此分割的方法總共會有m+1種(i = 0~m)，而同時我們也知道數列left_A的長度為i、right_A的長度為m-i。(備註：當 i = 0時，數列left_A是空的，且當i = m時right_A是空的。

用同樣的方法，在數列B中隨機取一個位置j

	     	left_B	        |          right_B
	B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]
    
再來將分割後的A、B數列分群，將左半部的A和左半部的B分為一群，右半部的A和右半部的B分為一群，可表示如下:

	     	left_part       |          right_part
	A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]
	B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]
    
藉由這樣的分群，我們還可以得到兩個兩個特性，1)左半部的數列長度一定等於右半部的數列長度，2)左半部的最大值一定小於等於右半部的最小值，以程式表示如下：

	1) len(left_part) == len(right_part)
	2) max(left_part) <= min(right_part)
    
利用這樣的特性，我們可以將所有在數列A、B中的元素等分為二，且其中一個數列一定大於另一個數列，這樣處理後的數列再根據上述中位數的特性，我們可以知道A、B數列中的中位數可以表示如下：

	median = (max(left_part) + min(right_part))/2

為了能夠滿足上面這兩個條件，因此我們必須確保:

	(1) i + j = m - i + n - j (or: m - i + n - j + 1)
    	當 n >= m 時，i = 0 ~ m, j = (m + n +1)/2 - i
    (2) B[j-1] <= A[i] 且 A[i-1] <= B[j]
    
為了方便解釋，這邊假定A[i-1],B[j-1],A[i],B[j]都是有效的值，即使在 i=0/i=m/j=0/j=n的情況下，(邊界問題之後再來處理)

有了上面的假設後，我們需要做的是在數列A中尋找一個位置i，而這個i位置得直要能滿足下列條件

	B[j-1] <= A[i] 且 A[i=1] <= B[j], j= (m + n +1)/2 - i
    
接下來可以依照下列步驟使用binary search

1. 設定起始參數 imin = 0, imax = m 
2. 設定 i = (imin + imax)/2, j = (m + n + 1)/2 - i
3. 現在我們已經可以將資料整理成 len(left_part) == len(right_part)的形式，在這個狀況下我們指會面臨到三種情形
	a. B[j-1] <= A[i] 且 A[i-1] <= B[j]
       這意味者我們找到滿足條件的位置i，停止搜尋
    b. B[j-1] > A[i]
       這個條件下表示A[i]的值太了，我們必須調整i的值，讓B[j-1] <= A[i]的條件成立，
       那麼是增加i的值？
          這個方法是對的，因為當i增加, j也會減少， 所以B[j-1]是下降，而A[i]則是上升，因此這樣的調整是有機會滿足條件 B[j-1] <= A[i]
       那是否可以減低i的值？
       答案是否定的，因為這樣永遠不可能滿足條件B[j-1] <= A[i]
       因此我們必須增加i的值，並將搜尋範圍設定為[i+1, imax]，因此設定imin = i+1，並回到步驟2
	c. A[i-1] > B[j]
       這意味著A[i-1]的值太大了，必須降低i的值，已設法滿足條件A[i-1]<=B[j]，因此必須將搜尋範圍設定為[imin, i-1]，因此將設定imax = i-1，並回到步驟2

當符合條件i出現時，中位數便可以表示如下

	1. m+n為奇數時，中位數為 max(A[i-1], B[j-1])
	2. m+n為偶數時，中位數為 (max(A[i-1], B[j-1]) + min(A[i], B[j])) /2

接下來討論邊界條件的問題，當i=0,i=m,j=0,j=n時，而A[i-1],B[j-1],A[i],B[j]可能並不存在，但真正實際上的情況可能比你想的還要簡單。
在我們一開始的時候就要確保條件max(left_part) <= min(right_part)是成立的，